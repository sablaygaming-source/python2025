//////
//COPY DEEPCOPY
That's a crucial concept in programming, often called Shallow Copy versus Deep Copy!

The behavior you are trying to avoid—where one variable modification affects another because they share the same memory address—happens by default with mutable objects (like lists and dictionaries) when you use the simple assignment operator (=).

To prevent this "aliasing" and ensure you get a completely new object that lives at a different memory address, you need to use specific functions.

The Solution: The copy Module
You should use the copy module, which provides two primary functions for creating copies:

copy.copy(): For a Shallow Copy.

copy.deepcopy(): For a Deep Copy.

include this   #import copy
The correct function depends on whether your data structure is nested (a list containing other lists, a dictionary containing other dictionaries, etc.).



////////
//FLOAT  INT FUNCTION
The Python float() Conversion Function

The float() function is Python's standard tool for converting strings (and integers) into floating-point numbers.

1. Core Usage

The function attempts to parse the input string and represent it as a number with a decimal component (i.e., a float).

Syntax: float(string_number)

Input String

float() Output

Resulting Type

"123.45"

123.45

float

"78"

78.0

float (Appends .0)

"-5.2e-3"

-0.0052

float (Handles scientific notation)

2. Why Use float() (The "Double" Equivalent)

When dealing with financial calculations, measurements, or any calculation requiring decimal precision, converting to float ensures that the standard arithmetic operators (+, -, *, /) work correctly with the fractional parts.

In Python:

int: Whole numbers (e.g., 5, -100)

float: Decimal/Fractional numbers (e.g., 5.0, -100.5, 3.14159)

3. Error Handling (Mandatory)

If the string contains any characters that cannot be interpreted as part of a valid number (e.g., letters, symbols, or multiple decimal points), float() will raise a ValueError. It is crucial to wrap conversion attempts in a try...except block to prevent your program from crashing.

try:
    number = float("12.3 dollars") # Invalid string
except ValueError:
    print("Invalid input for conversion.")


for integer

try: #5                
                iIdKey = int(sInput)
                if iIdKey <= 0 :#10
                    input("\nnegative numbers and 0 is not valid use higher than 0\npress any...")
                    continue    
                #10
            except ValueError as err: #5
                input("\nmust be a pure whole number only to be input\ndo not use .0 etc...\npress any...  ")
                continue
            #5



//////
// FORMAT   :.2F

//use string literal with :.2f then func format
formatted_dot_format = "{:.2f}".format(integer_value)

or in the tail of the last variable ex f"{ v:.2f}"
subSell['amount'] = f"{float( pProductData[ret]['amount'] ) * float(strInp):.2f}" 


///////
// DICT DISPLAY KEYS AND VALUES

 assume pData is array of dict
    ..displaying the keys, the keys always given in on set dict
    ..i use pData[0] the first element
    for keys in pData[0]:#5 
        print(keys + "     ", sep = "",end = "")
    #5
    
    ..pData is the main array of dict vDict each 1 set element dict
    for vDict in pData:#3
        ..vDict is a 1 set of dict every element
    
        for keys in vDict:#4
            ..to acces the value use keys ex: vDict[keys]
	    print(vDict[keys] + "     ", sep = "", end = "")
        #4
        print("")
    #3


/////
//  F STRING F"{}"  STR( )


Debugging TypeError: unsupported operand type(s) for +: 'int' and 'str'

The error you are seeing is a Type Error, which means you are trying to use an operation (+) on two different kinds of data (int and str) that Python doesn't know how to combine without help.

Original Error Location

Your code attempts to do this concatenation:

print(vDict[keys] + "      ", sep = "", end = "")
#         ^ int  +  ^ str  -> ERROR!


SOLUTION

Alternative Fix: Explicitly Convert to String

If you must use the + operator, use the str() function:

# Explicitly convert the integer to a string using str()
print(str(vDict[keys]) + "      ", sep = "", end = "")


Recommended Fix: Use F-Strings

F-strings (prefixed with f) are the standard way to embed variables inside strings, and they automatically handle type conversions for display.

# F-string automatically converts vDict[keys] to a string for printing.
# Note: You can also use the default print behavior and separate arguments with commas,
# which uses spaces as separators by default, but this preserves your original structure.
print(f"{vDict[keys]}      ", sep = "", end = "")

/////
//F"{}"  SECOND TOPIC

formatted_string = f"{truncated_string:<{max_width}}"

1.  **`truncated_string`**: This is the string content we want to format (which might already be cut down to 15 characters).
2.  **`:`**: Starts the format specification.
3.  **`<`**: Sets the alignment to **Left-Justified**. This means any extra space needed to meet the `max_width` will be added to the *right* side of the string. (If you used `>` it would be right-justified, and `^` would be centered).
4.  **`{max_width}`**: This dynamically inserts the value of the `max_width` variable (which is 15) as the total width of the field.

Together, `:<15` tells Python: "Make this string exactly 15 characters wide, and fill any empty space on the right with whitespace."



/////
//SLICE  FORMAT   MAX STRING AND MIN STRING  PADDING

When you combine this slicing technique with the formatting (padding) technique from our previous conversation, you get the robust fixed-width column:

Slice (Truncate): my_string[:15]

Format (Pad): f"{my_string[:15]:<15}"


//another sample preserving it to 15chars to display and if is less will add white space in a part that is lack of chars
nMax = 15

sInp = "num"
print(f"{sInp:<{nMax}}", sep ="", end ="")
sInp = "date"
print(f"{sInp:<{nMax}}", sep ="", end ="")
sInp = "amount"
print(f"{sInp:<{nMax}}", sep ="")


sInp = "12345678901234567890"
print(f"{sInp[:15]:<{nMax}}", sep ="", end ="")
sInp = "abc"
print(f"{sInp[:15]:<{nMax}}", sep ="", end ="")
sInp = "def"
print(f"{sInp[:15]:<{nMax}}", sep ="", end ="")

##################
# I got this on FreeBootCamp

def add_setting(pDict, pTuple):

	#if list(pDict.keys())[0].lower() == list(pTuple.keys())[0].lower(): #another way to convert to lower
		# pDict.keys( ) return dict_keys object, list( ) is needed to convert to list of string


    # Get the single key and value from pTuple
    new_key = list(pTuple.keys())[0]
    new_value = list(pTuple.values())[0]
    
    # Convert all existing keys to lowercase and check
    existing_keys_lower = [k.lower() for k in pDict.keys()]
    
    if new_key.lower() in existing_keys_lower:
        return f"Setting '{new_key}' already exists! Cannot add a new setting with this name"
    else:
        return f"Setting '{new_key}' added with a value '{new_value}' successfully"

var1 = {"theme": "dark"}
var2 = {"Theme": "light"}  # Different case but same key
Message = add_setting(var1, var2)
print(Message)
```

**Output:**
```
Setting 'Theme' already exists! Cannot add a new setting with this name

########################
# changing keys to lowercase  

#version for pop
pDict = {'ID': 1, 'NAME': "Ando", 'EMAIL': "Ando@email"}

# Change 'NAME' key to lowercase
if 'NAME' in pDict:
    pDict['name'] = pDict.pop('NAME')  #pop the name then replace by lower

print(pDict)  # {'ID': 1, 'name': 'Ando', 'EMAIL': 'Ando@email'}


#version for del
pDict = {'ID': 1, 'NAME': "Ando", 'EMAIL': "Ando@email"}

# Change 'NAME' key to lowercase
if 'NAME' in pDict:
    pDict['name'] = pDict['NAME']  
    del pDict['NAME'] #delete the uppercase

print(pDict)  # {'ID': 1, 'name': 'Ando', 'EMAIL': 'Ando@email'}



#####################
#use all lower of the dict to know if is equal of lower

Dict = {"name": "ando", "age": 25}
Dict2 = {"name": "beny", "age": 30}

# Check if both dicts have the same keys
if Dict.keys() == Dict2.keys():
    print("same keys")  # This will print

# Case-insensitive comparison of all keys
keys1 = {k.lower() for k in Dict.keys()}
keys2 = {k.lower() for k in Dict2.keys()}
if keys1 == keys2:
    print("same keys (case-insensitive)")



#########################################
# replace upper case to lower case keys in dict

def update_setting(pData, pInput):
    
    vkeys = list(pInput.keys())[0].lower()
    vValues = list(pInput.values())[0].lower()

    # Find the original key in pData (case-insensitive)
    original_key = None
    for k in pData.keys():
        if k.lower() == vkeys:
            original_key = k
            break
    
    if original_key:
        # Change the key to lowercase and update the value
        pData[vkeys] = pData.pop(original_key)
        pData[vkeys] = vValues
        return f"Setting '{vkeys}' updated to value '{vValues}' successfully"
    else:
        return f"Setting '{vkeys}' does not exist! Cannot update a non-existing setting"


var1 = {"COLOR": "Dark"}
var2 = {"COLOR": "Light"}

Message = update_setting(var1, var2)
print(Message)  # Setting 'color' updated to value 'light' successfully
print(var1)     # {'color': 'light'}


#################################
#filter all keys to lower case

my_dict = {"Name": "John", "Age": 25, "City": "NYC"}

# Convert all keys to lowercase
lowercase_dict = {k.lower(): v for k, v in my_dict.items()} #this hols by list

print(lowercase_dict)  # {'name': 'John', 'age': 25, 'city': 'NYC'}


######################
#dict  assigning a group

pDict = {"NAME": "Ando", "AGE": 25}

# Dictionary comprehension - uses { } with key:value
vKeysDict = {k.lower(): v for k, v in pDict.items()}  # : is needed if you want to asign keys and values 
print(vKeysDict)  # {'name': 'Ando', 'age': 25}
print(type(vKeysDict))  # <class 'dict'>

# List comprehension - uses [ ]
vKeysList = [k.lower() for k in pDict.keys()]     # assigns list of string for keys only  
						#u  can use solo category values  use pDict.values( )	
print(vKeysList)  # ['name', 'age']                   
print(type(vKeysList))  # <class 'list'>

# Set comprehension - uses { } without key:value
vKeysSet = {k.lower() for k in pDict.keys()}       # : is not needed if 1 category
print(vKeysSet)  # {'name', 'age'}
print(type(vKeysSet))  # <class 'set'>


#######
# 

#wrong use of keys() and values( )
var1.keys()  # Returns dict_keys(['ID', 'NAME', 'COLOR'])
# var1.keys(0)  # ❌ TypeError: 'dict_keys' object is not callable

# You must convert to list first:
list(var1.keys())[0]  # ✓ Returns 'ID'


#geting the keys and value thru list
var1 = {"ID": 1, "NAME": "ando", "COLOR": "Dark"}

keys_list = list(var1.keys())
values_list = list(var1.values())

for i in range(len(var1)):
    print(f"Key: {keys_list[i]}, Value: {values_list[i]}")

# Output:
# Key: ID, Value: 1
# Key: NAME, Value: ando
# Key: COLOR, Value: Dark

#same here get keys values but thru dict
var1 = {"ID": 1, "NAME": "ando", "COLOR": "Dark"}

for key, value in var1.items():
    print(f"Key: {key}, Value: {value}")

# Output:
# Key: ID, Value: 1
# Key: NAME, Value: ando
# Key: COLOR, Value: Dark

######
#tuple

dev = ('abc', 12, 'def')
var = tuple(dev[i] for i in range(len(dev)))  #need to use tuple( ) function if no tuple but ( ) use it create 							#generator
print(f"\n{var= }")  # var=('abc', 12, 'def')


dev = ('abc', 12, 'def')
var = tuple(v for v in dev)  # Convert generator to tuple
print(f"\n{var= }")  # var=('abc', 12, 'def')


dev = tuple(('abc', 12, 'def'))  #when tuple func use, need use ( ) inside data before tuple func
var = tuple (v  for v in dev)

print(f"\n{var= }")

#####
# kinds of sets

# Empty set - must use set() constructor
empty_set = set()  # ✓ Correct
# empty_set = {}   # ❌ Wrong! This creates an empty dictionary

# Set with values
my_set = {1, 2, 3, 4, 5}
print(my_set)  # {1, 2, 3, 4, 5}

# Set with mixed types
mixed_set = {1, 'apple', 3.14, True}
print(mixed_set)  # {1, 3.14, 'apple'}

# Set with strings
fruits = {'apple', 'banana', 'orange'}
print(fruits)  # {'apple', 'banana', 'orange'}


# Empty set
empty_set = set()
print(empty_set)  # set()

# From a list
my_set = set([1, 2, 3, 4, 5])
print(my_set)  # {1, 2, 3, 4, 5}

# From a string (splits into characters)
char_set = set('hello')
print(char_set)  # {'h', 'e', 'l', 'o'}

# From a tuple
tuple_set = set((1, 2, 3))
print(tuple_set)  # {1, 2, 3}

# Duplicates are removed
my_set = {1, 2, 2, 3, 3, 3, 4}
print(my_set)  # {1, 2, 3, 4}

# From list with duplicates
numbers = set([1, 1, 2, 2, 3, 3])
print(numbers)  # {1, 2, 3}


# Create set using comprehension
squares = {x**2 for x in range(5)}
print(squares)  # {0, 1, 4, 9, 16}

# With condition
evens = {x for x in range(10) if x % 2 == 0}
print(evens)  # {0, 2, 4, 6, 8}

#important notes
# Sets are unordered
my_set = {3, 1, 4, 2}
print(my_set)  # Order may vary: {1, 2, 3, 4}

# Sets cannot contain mutable types (like lists or dictionaries)
# invalid_set = {[1, 2], [3, 4]}  # ❌ TypeError

# But can contain tuples (immutable)
valid_set = {(1, 2), (3, 4)}  # ✓ Works
print(valid_set)  # {(1, 2), (3, 4)}


# Numbers
numbers = {1, 2, 3, 4, 5}

# Strings
colors = {'red', 'green', 'blue'}

# Mixed (but same type recommended)
mixed = {1, 2, 'three', 4.0}

# Empty set
empty = set()

# From range
range_set = set(range(1, 6))
print(range_set)  # {1, 2, 3, 4, 5}

Key takeaway: Use {} for non-empty sets, and set() for empty sets!



#######
# python library how to import module 

Now the import statement starts with from, followed by the name of the module, and then the import keyword followed by the name of the elements that you want to import:

from module_name import name1, name2


If you want to assign aliases to these names, you can do that by using the as keyword after each, followed by the alias you want to use:

from module_name import name1 as alias1, name2 as alias2


#####
# view object

view objects

A view object in Python is a dynamic object that provides a live view of the dictionary's entries (keys, values, or items). It automatically reflects any changes made to the dictionary.
View objects are returned by:

.keys() - view of dictionary keys
.values() - view of dictionary values
.items() - view of key-value pairs

my_dict = {'name': 'Ando', 'age': 25, 'city': 'NYC'}

keys_view = my_dict.keys()

# Loop through keys
for key in keys_view:
    print(key)
# name
# age
# city


#cannot do in view object
my_dict = {'name': 'Ando', 'age': 25, 'city': 'NYC'}

keys_view = my_dict.keys()

# ❌ Cannot use indexing
# print(keys_view[0])  # TypeError

# ❌ Cannot slice
# print(keys_view[0:2])  # TypeError

# ❌ Cannot use list methods
# keys_view.append('email')  # AttributeError
# keys_view.sort()  # AttributeError


#converting to diff types
my_dict = {'name': 'Ando', 'age': 25}

# Convert to list
keys_list = list(my_dict.keys())
print(keys_list)  # ['name', 'age']

values_list = list(my_dict.values())
print(values_list)  # ['Ando', 25]

items_list = list(my_dict.items())
print(items_list)  # [('name', 'Ando'), ('age', 25)]

# Convert to tuple
keys_tuple = tuple(my_dict.keys())
print(keys_tuple)  # ('name', 'age')

# Convert to set
keys_set = set(my_dict.keys())
print(keys_set)  # {'name', 'age'}


#practical use in view object
my_dict = {'name': 'Ando', 'age': 25, 'city': 'NYC'}

keys_view = my_dict.keys()
values_view = my_dict.values()
items_view = my_dict.items()

# Check if all keys are strings
all_strings = all(isinstance(k, str) for k in keys_view)
print(all_strings)  # True

# Count how many values are numbers
num_count = sum(1 for v in values_view if isinstance(v, int))
print(num_count)  # 1

# Find items where value > 20
filtered = [(k, v) for k, v in items_view if isinstance(v, int) and v > 20]
print(filtered)  # [('age', 25)]

important notes
Summary of what you CAN do:
✅ Check membership (in)
✅ Iterate with for loop
✅ Get length with len()
✅ Set operations (&, |, -, ^)
✅ Use in comprehensions
✅ Check truthiness
❌ Cannot index (view[0])
❌ Cannot slice (view[0:2])
❌ Cannot use list methods


#######
# isinstance( )


The isinstance() function checks if an object is an instance of a specified class or type. It's used for type checking.
Syntax:
pythonisinstance(object, classinfo)


# Check if variable is a specific type
x = 5
print(isinstance(x, int))      # True
print(isinstance(x, str))      # False


#another sample in multiple
x = 5

# Check if x is int OR float
print(isinstance(x, (int, float)))  # True

name = "Ando"
print(isinstance(name, (int, str, list)))  # True (it's a str)

my_dict = {'a': 1}
print(isinstance(my_dict, (list, tuple)))  # False



########
#try except else finally

try:
    num = int(input("Enter number: "))
    result = 10 / num
except ValueError:
    print("Invalid input!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
else:
    print(f"Result: {result}")
finally:
    print("Execution complete")



######
# enumerate with items()

my_dict = {
    "name": "Alice",
    "age": 25,
    "country": "Philippines"
}

for index, (key, value) in enumerate(my_dict.items()):
    print(f"Index: {index}, Key: {key}, Value: {value}")



#######
# type showing the datatype only

types_dict = {
    k: type(v).__name__     # use type(v)  the output will be <class int>
    for k, v in my_dict.items()
}

print(types_dict)


######
# tuple test list is tuple inside

def fDispList(pList, pPrompt = "\nDisplay List"): #2
    
    print(pPrompt)
    i = 0
    for k in pList: #3
        print(f"\nindex {i}, {k[0]}: {k[1]}")   #use keys[0] values[1] to access elements of tuple
    #3
    print( )
#2
vName = "NAME"
vValue = "Ando"
vDict = { "ID": 1, vName: vValue, "EMAIL": "Ando@email"} 


vList = [ ( k.lower() , v if isinstance( v, int) else v.lower() ) for k, v in vDict.items() ]  #every element is tuple then
											#a list of array is use

fDispList(vList)
print("\nend of aaprog")

#######
